<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lexer (lunno.Lunno_frontend.Lexer)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">lunno</a> &#x00BB; <a href="../index.html">Lunno_frontend</a> &#x00BB; Lexer</nav><header class="odoc-preamble"><h1>Module <code><span>Lunno_frontend.Lexer</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-string_buffer"><a href="#val-string_buffer" class="anchor"></a><code><span><span class="keyword">val</span> string_buffer : <span class="xref-unresolved">Stdlib</span>.Buffer.t</span></code></div><div class="spec-doc"><p>A reusable buffer for accumulating characters when parsing string literals.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reserved"><a href="#val-reserved" class="anchor"></a><code><span><span class="keyword">val</span> reserved : <span><span>(string, <span><a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Parser/index.html#type-token">Parser.token</a>)</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span></span></code></div><div class="spec-doc"><p>A hashtable of reserved keywords and their corresponding token representations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-strip_underscores"><a href="#val-strip_underscores" class="anchor"></a><code><span><span class="keyword">val</span> strip_underscores : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>strip_underscores s</code> returns a new string with all underscore characters ('_') removed from the input string <code>s</code>.</p><p>This function is useful for processing numeric literals that may include underscores for readability (e.g., &quot;1_000_000&quot; becomes &quot;1000000&quot;).</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">s</span> <p>The input string potentially containing underscores.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>A new string with all underscores removed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_pos"><a href="#val-with_pos" class="anchor"></a><code><span><span class="keyword">val</span> with_pos : <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_pos lexbuf ctor</code> constructs a token using the provided constructor <code>ctor</code> and the current lexeme's start and end positions from <code>lexbuf</code>.</p><p>This function retrieves the start and end positions of the current lexeme in the lexing buffer and applies the constructor <code>ctor</code> to create a token with the associated span.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">lexbuf</span> <p>The lexing buffer containing the input source code.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">ctor</span> <p>A constructor function that takes a <code>Span.t</code> and returns a token of type <code>'a</code>.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>A token of type <code>'a</code> constructed with the current lexeme's span.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-token"><a href="#val-token" class="anchor"></a><code><span><span class="keyword">val</span> token : <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span> <a href="../Parser/index.html#type-token">Parser.token</a></span></code></div><div class="spec-doc"><p><code>token lexbuf</code> reads and returns the next token from the given lexing buffer.</p><p>This is the main entry point for the lexer. It handles whitespace, comments, punctuation, identifiers, literals (integers, floats, strings), and keywords. It advances the lexing cursor as it consumes characters.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">lexbuf</span> <p>The lexing buffer containing the input source code.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The next token of type <code>Parser.token</code>.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Error.LexerError</code> <p>Raised if an invalid character, malformed number, or other lexical error is encountered.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_string"><a href="#val-read_string" class="anchor"></a><code><span><span class="keyword">val</span> read_string : 
  <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Lexing.position <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span>
  <a href="../Parser/index.html#type-token">Parser.token</a></span></code></div><div class="spec-doc"><p><code>read_string buffer start_pos lexbuf</code> parses a string literal starting at the current lexing position.</p><p>The function accumulates characters in <code>buffer</code> until it reaches a closing double-quote. It handles valid escape sequences (e.g., '\n', '\t', '\&quot;') and raises errors for invalid escapes, newlines, or unterminated strings.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">buffer</span> <p>A <code>Buffer.t</code> to accumulate string contents.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">start_pos</span> <p>The starting position of the string literal in the source, used for accurate error reporting.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">lexbuf</span> <p>The lexing buffer containing the input source code.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>A <code>Token.token</code> representing the string literal.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Error.LexerError</code> <p>Raised if the string is empty, contains invalid escape sequences, includes a newline, or is unterminated.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_comment"><a href="#val-read_comment" class="anchor"></a><code><span><span class="keyword">val</span> read_comment : <span><span class="xref-unresolved">Stdlib</span>.Lexing.lexbuf <span class="arrow">&#45;&gt;</span></span> <a href="../Parser/index.html#type-token">Parser.token</a></span></code></div><div class="spec-doc"><p><code>read_comment lexbuf</code> skips over a comment starting with '#' until the end of the line or EOF.</p><p>The function advances the lexing cursor past the comment and returns the next token after the comment.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">lexbuf</span> <p>The lexing buffer containing the input source code.</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The next token following the comment.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Error.LexerError</code> <p>Raised if an unexpected end-of-file occurs within a comment, although line comments usually terminate at the end of line.</p></li></ul></div></div></div></body></html>
