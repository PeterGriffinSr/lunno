<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast (lunno.Lunno_frontend.Ast)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">lunno</a> &#x00BB; <a href="../index.html">Lunno_frontend</a> &#x00BB; Ast</nav><header class="odoc-preamble"><h1>Module <code><span>Lunno_frontend.Ast</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-ty"><a href="#type-ty" class="anchor"></a><code><span><span class="keyword">type</span> ty</span><span> = </span></code><ol><li id="type-ty.TyInt" class="def variant constructor anchored"><a href="#type-ty.TyInt" class="anchor"></a><code><span>| </span><span><span class="constructor">TyInt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer type.</p><span class="comment-delim">*)</span></div></li><li id="type-ty.TyFloat" class="def variant constructor anchored"><a href="#type-ty.TyFloat" class="anchor"></a><code><span>| </span><span><span class="constructor">TyFloat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Floating-point type.</p><span class="comment-delim">*)</span></div></li><li id="type-ty.TyString" class="def variant constructor anchored"><a href="#type-ty.TyString" class="anchor"></a><code><span>| </span><span><span class="constructor">TyString</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>String type.</p><span class="comment-delim">*)</span></div></li><li id="type-ty.TyBool" class="def variant constructor anchored"><a href="#type-ty.TyBool" class="anchor"></a><code><span>| </span><span><span class="constructor">TyBool</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean type.</p><span class="comment-delim">*)</span></div></li><li id="type-ty.TyUnit" class="def variant constructor anchored"><a href="#type-ty.TyUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">TyUnit</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unit type.</p><span class="comment-delim">*)</span></div></li><li id="type-ty.TyVar" class="def variant constructor anchored"><a href="#type-ty.TyVar" class="anchor"></a><code><span>| </span><span><span class="constructor">TyVar</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Type variable, e.g., 'a.</p><span class="comment-delim">*)</span></div></li><li id="type-ty.TyList" class="def variant constructor anchored"><a href="#type-ty.TyList" class="anchor"></a><code><span>| </span><span><span class="constructor">TyList</span> <span class="keyword">of</span> <a href="#type-ty">ty</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>List type, e.g., <code>int</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-ty.TyFunction" class="def variant constructor anchored"><a href="#type-ty.TyFunction" class="anchor"></a><code><span>| </span><span><span class="constructor">TyFunction</span> <span class="keyword">of</span> <span><a href="#type-ty">ty</a> list</span> * <a href="#type-ty">ty</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function type, e.g., (int, int) -&gt; int.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The <code>ty</code> type represents types in the language.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-literal"><a href="#type-literal" class="anchor"></a><code><span><span class="keyword">type</span> literal</span><span> = </span></code><ol><li id="type-literal.LInt" class="def variant constructor anchored"><a href="#type-literal.LInt" class="anchor"></a><code><span>| </span><span><span class="constructor">LInt</span> <span class="keyword">of</span> int64</span></code></li><li id="type-literal.LFloat" class="def variant constructor anchored"><a href="#type-literal.LFloat" class="anchor"></a><code><span>| </span><span><span class="constructor">LFloat</span> <span class="keyword">of</span> float</span></code></li><li id="type-literal.LString" class="def variant constructor anchored"><a href="#type-literal.LString" class="anchor"></a><code><span>| </span><span><span class="constructor">LString</span> <span class="keyword">of</span> string</span></code></li><li id="type-literal.LBool" class="def variant constructor anchored"><a href="#type-literal.LBool" class="anchor"></a><code><span>| </span><span><span class="constructor">LBool</span> <span class="keyword">of</span> bool</span></code></li><li id="type-literal.LUnit" class="def variant constructor anchored"><a href="#type-literal.LUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">LUnit</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-param"><a href="#type-param" class="anchor"></a><code><span><span class="keyword">type</span> param</span><span> = </span><span>{</span></code><ol><li id="type-param.param_name" class="def record field anchored"><a href="#type-param.param_name" class="anchor"></a><code><span>param_name : string;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Parameter name.</p><span class="comment-delim">*)</span></div></li><li id="type-param.param_ty" class="def record field anchored"><a href="#type-param.param_ty" class="anchor"></a><code><span>param_ty : <span><a href="#type-ty">ty</a> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Optional type annotation.</p><span class="comment-delim">*)</span></div></li><li id="type-param.param_span" class="def record field anchored"><a href="#type-param.param_span" class="anchor"></a><code><span>param_span : <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Source code span of the parameter.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The <code>param</code> type represents a function parameter.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-import"><a href="#type-import" class="anchor"></a><code><span><span class="keyword">type</span> import</span><span> = </span><span>{</span></code><ol><li id="type-import.module_" class="def record field anchored"><a href="#type-import.module_" class="anchor"></a><code><span>module_ : string;</span></code></li><li id="type-import.item" class="def record field anchored"><a href="#type-import.item" class="anchor"></a><code><span>item : string;</span></code></li><li id="type-import.import_span" class="def record field anchored"><a href="#type-import.import_span" class="anchor"></a><code><span>import_span : <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span><span> = </span></code><ol><li id="type-expr.Literal" class="def variant constructor anchored"><a href="#type-expr.Literal" class="anchor"></a><code><span>| </span><span><span class="constructor">Literal</span> <span class="keyword">of</span> <a href="#type-literal">literal</a> * <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Literal reference.</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Variable" class="def variant constructor anchored"><a href="#type-expr.Variable" class="anchor"></a><code><span>| </span><span><span class="constructor">Variable</span> <span class="keyword">of</span> string * <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variable reference.</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Lambda" class="def variant constructor anchored"><a href="#type-expr.Lambda" class="anchor"></a><code><span>| </span><span><span class="constructor">Lambda</span> <span class="keyword">of</span> <a href="#type-lambda">lambda</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Lambda / anonymous function.</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Apply" class="def variant constructor anchored"><a href="#type-expr.Apply" class="anchor"></a><code><span>| </span><span><span class="constructor">Apply</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <span><a href="#type-expr">expr</a> list</span> * <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function application.</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Let" class="def variant constructor anchored"><a href="#type-expr.Let" class="anchor"></a><code><span>| </span><span><span class="constructor">Let</span> <span class="keyword">of</span> <a href="#type-let_expr">let_expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Let binding expression.</p><span class="comment-delim">*)</span></div></li><li id="type-expr.If" class="def variant constructor anchored"><a href="#type-expr.If" class="anchor"></a><code><span>| </span><span><span class="constructor">If</span> <span class="keyword">of</span> <a href="#type-if_expr">if_expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If expression.</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Match" class="def variant constructor anchored"><a href="#type-expr.Match" class="anchor"></a><code><span>| </span><span><span class="constructor">Match</span> <span class="keyword">of</span> <a href="#type-match_expr">match_expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Match expression.</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Block" class="def variant constructor anchored"><a href="#type-expr.Block" class="anchor"></a><code><span>| </span><span><span class="constructor">Block</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> list</span> * <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Block expression.</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Binary" class="def variant constructor anchored"><a href="#type-expr.Binary" class="anchor"></a><code><span>| </span><span><span class="constructor">Binary</span> <span class="keyword">of</span> <a href="#type-binary_expr">binary_expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Binary operation.</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Unary" class="def variant constructor anchored"><a href="#type-expr.Unary" class="anchor"></a><code><span>| </span><span><span class="constructor">Unary</span> <span class="keyword">of</span> <a href="#type-unary_expr">unary_expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unary operation.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The <code>expr</code> type represents all expressions in the language.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-lambda"><a href="#type-lambda" class="anchor"></a><code><span><span class="keyword">and</span> lambda</span><span> = </span><span>{</span></code><ol><li id="type-lambda.params" class="def record field anchored"><a href="#type-lambda.params" class="anchor"></a><code><span>params : <span><a href="#type-param">param</a> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Parameters.</p><span class="comment-delim">*)</span></div></li><li id="type-lambda.ret_ty" class="def record field anchored"><a href="#type-lambda.ret_ty" class="anchor"></a><code><span>ret_ty : <span><a href="#type-ty">ty</a> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Optional return type annotation.</p><span class="comment-delim">*)</span></div></li><li id="type-lambda.lambda_body" class="def record field anchored"><a href="#type-lambda.lambda_body" class="anchor"></a><code><span>lambda_body : <a href="#type-expr">expr</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function body.</p><span class="comment-delim">*)</span></div></li><li id="type-lambda.is_recursive" class="def record field anchored"><a href="#type-lambda.is_recursive" class="anchor"></a><code><span>is_recursive : bool;</span></code></li><li id="type-lambda.lambda_span" class="def record field anchored"><a href="#type-lambda.lambda_span" class="anchor"></a><code><span>lambda_span : <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Span of the whole lambda.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The <code>lambda</code> type represents anonymous functions.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-let_expr"><a href="#type-let_expr" class="anchor"></a><code><span><span class="keyword">and</span> let_expr</span><span> = </span><span>{</span></code><ol><li id="type-let_expr.name" class="def record field anchored"><a href="#type-let_expr.name" class="anchor"></a><code><span>name : string;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Name being bound.</p><span class="comment-delim">*)</span></div></li><li id="type-let_expr.ty" class="def record field anchored"><a href="#type-let_expr.ty" class="anchor"></a><code><span>ty : <span><a href="#type-ty">ty</a> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Optional type annotation.</p><span class="comment-delim">*)</span></div></li><li id="type-let_expr.let_body" class="def record field anchored"><a href="#type-let_expr.let_body" class="anchor"></a><code><span>let_body : <a href="#type-expr">expr</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Expression being bound.</p><span class="comment-delim">*)</span></div></li><li id="type-let_expr.let_span" class="def record field anchored"><a href="#type-let_expr.let_span" class="anchor"></a><code><span>let_span : <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Span of the let expression.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The <code>let_expr</code> type represents let bindings.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-if_expr"><a href="#type-if_expr" class="anchor"></a><code><span><span class="keyword">and</span> if_expr</span><span> = </span><span>{</span></code><ol><li id="type-if_expr.cond" class="def record field anchored"><a href="#type-if_expr.cond" class="anchor"></a><code><span>cond : <a href="#type-expr">expr</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Condition expression.</p><span class="comment-delim">*)</span></div></li><li id="type-if_expr.then_" class="def record field anchored"><a href="#type-if_expr.then_" class="anchor"></a><code><span>then_ : <a href="#type-expr">expr</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Then branch.</p><span class="comment-delim">*)</span></div></li><li id="type-if_expr.else_" class="def record field anchored"><a href="#type-if_expr.else_" class="anchor"></a><code><span>else_ : <span><a href="#type-expr">expr</a> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Else branch.</p><span class="comment-delim">*)</span></div></li><li id="type-if_expr.if_span" class="def record field anchored"><a href="#type-if_expr.if_span" class="anchor"></a><code><span>if_span : <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Span of the if expression.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The <code>if_expr</code> type represents if expressions.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-match_expr"><a href="#type-match_expr" class="anchor"></a><code><span><span class="keyword">and</span> match_expr</span><span> = </span><span>{</span></code><ol><li id="type-match_expr.scrutinee" class="def record field anchored"><a href="#type-match_expr.scrutinee" class="anchor"></a><code><span>scrutinee : <a href="#type-expr">expr</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Expression being matched on.</p><span class="comment-delim">*)</span></div></li><li id="type-match_expr.cases" class="def record field anchored"><a href="#type-match_expr.cases" class="anchor"></a><code><span>cases : <span><a href="#type-match_case">match_case</a> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>List of match cases.</p><span class="comment-delim">*)</span></div></li><li id="type-match_expr.match_span" class="def record field anchored"><a href="#type-match_expr.match_span" class="anchor"></a><code><span>match_span : <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Span of the match expression.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The <code>match_expr</code> type represents match expressions.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-match_case"><a href="#type-match_case" class="anchor"></a><code><span><span class="keyword">and</span> match_case</span><span> = </span><span>{</span></code><ol><li id="type-match_case.pattern" class="def record field anchored"><a href="#type-match_case.pattern" class="anchor"></a><code><span>pattern : <a href="#type-pattern">pattern</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pattern to match.</p><span class="comment-delim">*)</span></div></li><li id="type-match_case.guard" class="def record field anchored"><a href="#type-match_case.guard" class="anchor"></a><code><span>guard : <span><a href="#type-expr">expr</a> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Optional guard expression.</p><span class="comment-delim">*)</span></div></li><li id="type-match_case.case_body" class="def record field anchored"><a href="#type-match_case.case_body" class="anchor"></a><code><span>case_body : <a href="#type-expr">expr</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Expression for the case body.</p><span class="comment-delim">*)</span></div></li><li id="type-match_case.case_span" class="def record field anchored"><a href="#type-match_case.case_span" class="anchor"></a><code><span>case_span : <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Span of the case.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The <code>match_case</code> type represents a single match case.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span><span class="keyword">and</span> pattern</span><span> = </span></code><ol><li id="type-pattern.PWildcard" class="def variant constructor anchored"><a href="#type-pattern.PWildcard" class="anchor"></a><code><span>| </span><span><span class="constructor">PWildcard</span> <span class="keyword">of</span> <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Wildcard pattern <code>_</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PVariable" class="def variant constructor anchored"><a href="#type-pattern.PVariable" class="anchor"></a><code><span>| </span><span><span class="constructor">PVariable</span> <span class="keyword">of</span> string * <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variable pattern.</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PIntLiteral" class="def variant constructor anchored"><a href="#type-pattern.PIntLiteral" class="anchor"></a><code><span>| </span><span><span class="constructor">PIntLiteral</span> <span class="keyword">of</span> int64 * <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer literal pattern.</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PFloatLiteral" class="def variant constructor anchored"><a href="#type-pattern.PFloatLiteral" class="anchor"></a><code><span>| </span><span><span class="constructor">PFloatLiteral</span> <span class="keyword">of</span> float * <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Float literal pattern.</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PStringLiteral" class="def variant constructor anchored"><a href="#type-pattern.PStringLiteral" class="anchor"></a><code><span>| </span><span><span class="constructor">PStringLiteral</span> <span class="keyword">of</span> string * <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>String literal pattern.</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PBooleanLiteral" class="def variant constructor anchored"><a href="#type-pattern.PBooleanLiteral" class="anchor"></a><code><span>| </span><span><span class="constructor">PBooleanLiteral</span> <span class="keyword">of</span> bool * <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean literal pattern.</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PNil" class="def variant constructor anchored"><a href="#type-pattern.PNil" class="anchor"></a><code><span>| </span><span><span class="constructor">PNil</span> <span class="keyword">of</span> <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Empty list pattern .</p><span class="comment-delim">*)</span></div></li><li id="type-pattern.PCons" class="def variant constructor anchored"><a href="#type-pattern.PCons" class="anchor"></a><code><span>| </span><span><span class="constructor">PCons</span> <span class="keyword">of</span> <a href="#type-pattern">pattern</a> * <a href="#type-pattern">pattern</a> * <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Cons pattern (head :: tail).</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The <code>pattern</code> type represents patterns in match expressions.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-binary_op"><a href="#type-binary_op" class="anchor"></a><code><span><span class="keyword">and</span> binary_op</span><span> = </span></code><ol><li id="type-binary_op.OpAdd" class="def variant constructor anchored"><a href="#type-binary_op.OpAdd" class="anchor"></a><code><span>| </span><span><span class="constructor">OpAdd</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><ol><li>operator.</li></ol><span class="comment-delim">*)</span></div></li><li id="type-binary_op.OpSub" class="def variant constructor anchored"><a href="#type-binary_op.OpSub" class="anchor"></a><code><span>| </span><span><span class="constructor">OpSub</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><ul><li>operator.</li></ul><span class="comment-delim">*)</span></div></li><li id="type-binary_op.OpMul" class="def variant constructor anchored"><a href="#type-binary_op.OpMul" class="anchor"></a><code><span>| </span><span><span class="constructor">OpMul</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>* operator.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_op.OpDiv" class="def variant constructor anchored"><a href="#type-binary_op.OpDiv" class="anchor"></a><code><span>| </span><span><span class="constructor">OpDiv</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>/ operator.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_op.OpEqual" class="def variant constructor anchored"><a href="#type-binary_op.OpEqual" class="anchor"></a><code><span>| </span><span><span class="constructor">OpEqual</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>= operator.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_op.OpNotEqual" class="def variant constructor anchored"><a href="#type-binary_op.OpNotEqual" class="anchor"></a><code><span>| </span><span><span class="constructor">OpNotEqual</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>&lt;&gt; operator.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_op.OpLess" class="def variant constructor anchored"><a href="#type-binary_op.OpLess" class="anchor"></a><code><span>| </span><span><span class="constructor">OpLess</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>&lt; operator.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_op.OpGreater" class="def variant constructor anchored"><a href="#type-binary_op.OpGreater" class="anchor"></a><code><span>| </span><span><span class="constructor">OpGreater</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>&gt; operator.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_op.OpCons" class="def variant constructor anchored"><a href="#type-binary_op.OpCons" class="anchor"></a><code><span>| </span><span><span class="constructor">OpCons</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>:: operator.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The <code>binary_op</code> type represents binary operators.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-unary_op"><a href="#type-unary_op" class="anchor"></a><code><span><span class="keyword">and</span> unary_op</span><span> = </span></code><ol><li id="type-unary_op.OpNegate" class="def variant constructor anchored"><a href="#type-unary_op.OpNegate" class="anchor"></a><code><span>| </span><span><span class="constructor">OpNegate</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unary minus operator.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The <code>unary_op</code> type represents unary operators.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-binary_expr"><a href="#type-binary_expr" class="anchor"></a><code><span><span class="keyword">and</span> binary_expr</span><span> = </span><span>{</span></code><ol><li id="type-binary_expr.binary_op" class="def record field anchored"><a href="#type-binary_expr.binary_op" class="anchor"></a><code><span>binary_op : <a href="#type-binary_op">binary_op</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Operator.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_expr.left" class="def record field anchored"><a href="#type-binary_expr.left" class="anchor"></a><code><span>left : <a href="#type-expr">expr</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Left-hand side expression.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_expr.right" class="def record field anchored"><a href="#type-binary_expr.right" class="anchor"></a><code><span>right : <a href="#type-expr">expr</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Right-hand side expression.</p><span class="comment-delim">*)</span></div></li><li id="type-binary_expr.binary_span" class="def record field anchored"><a href="#type-binary_expr.binary_span" class="anchor"></a><code><span>binary_span : <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Span of the binary expression.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The <code>binary_expr</code> type represents binary operations in expressions.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-unary_expr"><a href="#type-unary_expr" class="anchor"></a><code><span><span class="keyword">and</span> unary_expr</span><span> = </span><span>{</span></code><ol><li id="type-unary_expr.unary_op" class="def record field anchored"><a href="#type-unary_expr.unary_op" class="anchor"></a><code><span>unary_op : <a href="#type-unary_op">unary_op</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Operator.</p><span class="comment-delim">*)</span></div></li><li id="type-unary_expr.expr" class="def record field anchored"><a href="#type-unary_expr.expr" class="anchor"></a><code><span>expr : <a href="#type-expr">expr</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Expression operand.</p><span class="comment-delim">*)</span></div></li><li id="type-unary_expr.unary_span" class="def record field anchored"><a href="#type-unary_expr.unary_span" class="anchor"></a><code><span>unary_span : <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Span of the unary expression.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The <code>unary_expr</code> type represents unary operations in expressions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-span_of_expr"><a href="#val-span_of_expr" class="anchor"></a><code><span><span class="keyword">val</span> span_of_expr : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Lunno_common/Span/index.html#type-t">Lunno_common.Span.t</a></span></code></div><div class="spec-doc"><p><code>span_of_expr e</code> returns the source span of expression <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-program"><a href="#type-program" class="anchor"></a><code><span><span class="keyword">type</span> program</span><span> = </span><span>{</span></code><ol><li id="type-program.imports" class="def record field anchored"><a href="#type-program.imports" class="anchor"></a><code><span>imports : <span><a href="#type-import">import</a> list</span>;</span></code></li><li id="type-program.body" class="def record field anchored"><a href="#type-program.body" class="anchor"></a><code><span>body : <span><a href="#type-expr">expr</a> list</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The <code>program</code> type represents a sequence of expressions (the top-level program).</p></div></div></div></body></html>
